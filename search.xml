<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Kalmar CTF 2025</title>
    <url>/2025/03/10/kalmarctf2025/</url>
    <content><![CDATA[<p>I played with r3kapig last weekend, and we managed to solve 5 out of 8 crypto challs. </p>
<span id="more"></span>

<h1 id="ZZKAoK-6-solves"><a href="#ZZKAoK-6-solves" class="headerlink" title="ZZKAoK (6 solves)"></a>ZZKAoK (6 solves)</h1><blockquote>
<ul>
<li><a href="ZZKAoK/client.sage">client.sage</a></li>
<li><a href="ZZKAoK/server.py">server.py</a></li>
<li><a href="ZZKAoK/intarg.py">intarg.py</a></li>
</ul>
</blockquote>
<p>I’ll explain this challenge following my path during the contest -&gt; logical confusion and nonsense.</p>
<h3 id="Zk-Proof-System"><a href="#Zk-Proof-System" class="headerlink" title="Zk Proof System"></a>Zk Proof System</h3><p>Here comes a proof system for integer factorization. Given $N$, the Prover $\mathcal{P}$ can show the knowledge of two factors $(p, q)$ satisfying $N &#x3D; p \cdot q$ to the Verifier $\mathcal{V}$, though the following constraints:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># relation to prove:</span></span><br><span class="line"><span class="comment"># p \notin &#123;-1, 1&#125;</span></span><br><span class="line"><span class="comment"># q \notin &#123;-1, 1&#125;</span></span><br><span class="line"><span class="comment"># p * q = N</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># via:</span></span><br><span class="line"><span class="comment"># a^2 - 4 &gt;= 0 &lt;=&gt; a \notin &#123;-1, 1&#125;</span></span><br><span class="line"><span class="comment"># b^2 - 4 &gt;= 0 &lt;=&gt; b \notin &#123;-1, 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arithmetic circuit:</span></span><br><span class="line"><span class="comment"># p * q = N</span></span><br><span class="line"><span class="comment"># a1^2 + a2^2 + a3^2 + a4^2 = p^2 - 4</span></span><br><span class="line"><span class="comment"># b1^2 + b2^2 + b3^2 + b4^2 = q^2 - 4</span></span><br></pre></td></tr></table></figure>

<p>Apparently $\mathcal{P}$ is able to compute a valid proof if and only if he knows the factors.</p>
<p>But we don’t want to reveal any other information about the factors (thus zeor-knowledge), so $\mathcal{P}$ CANNOT just send the values to $\mathcal{V}$. Instead, we randomly choose small prime $p_i$ and check the constraints on $GF_{p_i}$. Our proof is more reliable with more primes chosen, as analyzed in the challenge:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TOTAL_PRIME_BITS = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> PRIMES:</span><br><span class="line">    TOTAL_PRIME_BITS += p.bit_length() - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">BITS = <span class="number">50_000</span>                              <span class="comment"># maximum norm, bits</span></span><br><span class="line">SECP = <span class="number">256</span>                                 <span class="comment"># \secpar</span></span><br><span class="line">RATE = (TOTAL_PRIME_BITS + BITS - <span class="number">1</span>)//BITS <span class="comment"># rate</span></span><br><span class="line">SECB = RATE.bit_length() - <span class="number">1</span>               <span class="comment"># security bits per query</span></span><br><span class="line">QUERIES = (SECP + SECB - <span class="number">1</span>) // SECB        <span class="comment"># total number of queries</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(PRIMES) == <span class="number">1</span> &lt;&lt; NUML</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In fact $\mathcal{P}$ leaks $secret \pmod{p_i}$ in this process, so this is technically not that “zero-knowledge”.</p>
</blockquote>
<p>For a secure proof system, we must make sure $\mathcal{P}$ computed the proof correctly, rather than giving a random answer on $GF_{p_i}$. Here is how we do:</p>
<ol>
<li>$\mathcal{P}$ makes commitments on secret values.</li>
<li>$\mathcal{V}$ chooses some primes $p_i \in PRIMES$.</li>
<li>$\mathcal{P}$ computes constraints inputs and outputs values on $GF_{p_i}$.</li>
<li>$\mathcal{V}$ check the validity on $GF_{p_i}$.</li>
</ol>
<h3 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h3><p>With Commitment Scheme, we ensure that $\mathcal{P}$ cannot modify input values in the subsequnt proof steps. Here the challenge uses Merkle Tree Commitment, which is suitable for set commitment and membership open&#x2F;proof.</p>
<ol>
<li>$\mathcal{P}$ computes $secret \pmod{p_i}$ on all $p_i \in PRIMES$, storing in a list.</li>
<li>$\mathcal{P}$ generates a Merkle Tree on the list, using Tree Root as the commitment.</li>
<li>For a chosen prime $p_i$, $\mathcal{P}$ opens the commitment by providing the Merkle Path of $secret \pmod{p_i}$.</li>
</ol>
<p>Then we can make sure $\mathcal{P}$ is using $secret \pmod{p_i}$ with the committed $secret$.</p>
<h3 id="NIZK"><a href="#NIZK" class="headerlink" title="NIZK"></a>NIZK</h3><p>What we have is a interactive proof system. For a non-interactive one, we need $\mathcal{P}$ to generate challenge data on his own while ensuring security. We introduce a <code>transcript</code> structure:</p>
<ul>
<li>The internal state of the transcript gets changes every time $\mathcal{P}$ performs operations such as commit and evaluate.</li>
<li>$\mathcal{P}$ generates random values based on the internal state of the transcript as challenge data provided from $\mathcal{V}$.</li>
</ul>
<p>The <code>transcript</code> binds its internal state to the proof operations, while its subsequent output is determined but unpredictable. This is an important structure in non-interactive zero-knowledge proofs. Check <a href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic">Fiat-Shamir Heuristic</a>.</p>
<p>And here comes our NIZK:</p>
<p>$\mathcal{P}$:</p>
<ol>
<li>$\mathcal{P}$ makes commitments on secret values.</li>
<li>$\mathcal{P}$ gets some primes $p_i \in PRIMES$ from <code>transcripts</code>.</li>
<li>$\mathcal{P}$ opens the commitments on the chosen $p_i$.</li>
<li>$\mathcal{P}$ computes constraints inputs and outputs values on $GF_{p_i}$.</li>
</ol>
<p>$\mathcal{V}$:</p>
<ol>
<li>$\mathcal{V}$ repeats the whole process to get the status of the <code>transcript</code>.</li>
<li>$\mathcal{V}$ checks the validity of the opens.</li>
<li>$\mathcal{V}$ verify the validity of the proof.</li>
</ol>
<p>In addition to the target constraints, we need to add a new constraint binding all the commitments (a linear one is ok). </p>
<h3 id="Vuln1-Unintended"><a href="#Vuln1-Unintended" class="headerlink" title="Vuln1 (Unintended)"></a>Vuln1 (Unintended)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Merkle Tree Path Verification</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">root: <span class="built_in">str</span>, proof: <span class="built_in">list</span>, pos: <span class="built_in">int</span>, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(proof) &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(proof) &lt; <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    lvls = <span class="built_in">len</span>(proof) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">1</span> &lt;&lt; lvls == size</span><br><span class="line"></span><br><span class="line">    leaf = proof[<span class="number">0</span>]</span><br><span class="line">    node = sha256(leaf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lvls+<span class="number">1</span>):</span><br><span class="line">        (dirc, sibl) = proof[i]</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(sibl, <span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(dirc, <span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(sibl) == <span class="number">64</span></span><br><span class="line">        <span class="keyword">assert</span> dirc <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> dirc == <span class="number">0</span>:</span><br><span class="line">            node = sha256(node + sibl)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = sha256(sibl + node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> node == root</span><br><span class="line">    <span class="keyword">return</span> leaf</span><br></pre></td></tr></table></figure>

<p>We can find that the verification for Merkle Tree Path does not check whether the <code>path</code> corresponds to the <code>pos</code>, so we can choose any valid <code>path</code> from the tree when opening. My strategy is as follows:</p>
<ol>
<li>$p &#x3D; N, q &#x3D; 1$</li>
<li>$four(a_1, a_2, a_3, a_4) &#x3D; p^2 - 4$</li>
<li>$(b_1, b_2, b_3, b_4) &#x3D; (rand, rand, rand, rand)$</li>
</ol>
<p>For each $pos$, we should find three positions $(i, j, k)$ where $(b_2, b_3, b_4)$ can be opened to satisfy the constraints. I just iterate through $i$ and solve the following equations:</p>
<ol>
<li>$b_3^2 + b_4^2 &#x3D; r \pmod{p_i}$</li>
<li>$f_0 \cdot b_3 + f_1 \cdot b_4 &#x3D; v \pmod{p_i}$</li>
</ol>
<p>After finding possible solutions, we can then check if there are positions $(j, k)$ that satisfy the solutions.</p>
<h3 id="Vuln2-Intended"><a href="#Vuln2-Intended" class="headerlink" title="Vuln2 (Intended)"></a>Vuln2 (Intended)</h3><p>The second vuln lies in the final constraint over all the commitments. This time our strategy is more direct:</p>
<ol>
<li>$p &#x3D; N, q &#x3D; 1$</li>
<li>$four(a_1, a_2, a_3, a_4) &#x3D; p^2 - 4$</li>
<li>find $(b_1, b_2, b_3, b_4)$ such that $\forall p_i \in PRIMES \rightarrow (b_1, b_2, b_3, b_4) &#x3D; (-1, -1, -1, 0) \pmod{p_i}$</li>
</ol>
<p>Or something else, satisfying $b_1^2 + b_2^2 + b_3^2 + b_4^2 &#x3D; -3 \pmod{p_i}$. It turns out that one can easily find a solution with CRT, which will be very large. The value of the last constraints (linear combined commitments) is too large to pass the following code in <code>Verifier</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Verifier</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">value</span>(<span class="params">self</span>):</span><br><span class="line">        value = <span class="built_in">next</span>(<span class="variable language_">self</span>.vals)</span><br><span class="line">        <span class="keyword">assert</span> - <span class="number">2</span>**BITS &lt; value &lt; <span class="number">2</span>**BITS</span><br><span class="line">        <span class="variable language_">self</span>.tx.value(value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<p>Actually $\mathcal{V}$ does NOT check how many commitments are used, and the verification for the last constraint just sum all of them up. So we can add an extra “unauthorized” commitment to control the value to zero. Since <code>transcript</code> is unchanged, we can first get both the constraint and all the $p_i$, and then construct out commitment. </p>
<p>During the contest we did notice some strange implementations in the challenge.</p>
<table>
<thead>
<tr>
<th><img src="/2025/03/10/kalmarctf2025/images/1.png" alt="image"></th>
<th><img src="/2025/03/10/kalmarctf2025/images/2.png" alt="image"></th>
</tr>
</thead>
</table>
<p>But nobody gave it a further analysis XD</p>
]]></content>
      <tags>
        <tag>zkp</tag>
      </tags>
  </entry>
  <entry>
    <title>SECCON CTF 2025</title>
    <url>/2025/03/04/secconctf2025/</url>
    <content><![CDATA[<p>I participated SECCON 13th Final as a member of P1G SEKAI this weekend, and we finally got 4th among international teams.</p>
<p><img src="/2025/03/04/secconctf2025/images/2.jpg" alt="rank"></p>
<p>Nice crypto challenges, and I solved 3 out of 4. IF ONLY I’d ever taken some time to study UOV.</p>
<p><img src="/2025/03/04/secconctf2025/images/1.png" alt="solve"></p>
<p>Or maybe I was just too nervous.</p>
<p>XO</p>
<h1 id="RSA-8-solved"><a href="#RSA-8-solved" class="headerlink" title="RSA+ (8 solved)"></a>RSA+ (8 solved)</h1><blockquote>
<ul>
<li><a href="RSA+/task.py">task.py</a></li>
</ul>
</blockquote>
<p>It turns out that we can send two composite number $(p, q)$, both smaller than 512 bits. Then we can just find all the solutions on $p_i$ and combine them with CRT. I believe there exists a better way though.</p>
<blockquote>
<p>solution: <a href="RSA+/exp.py">exp.py</a></p>
</blockquote>
<h1 id="DLP-7-solved"><a href="#DLP-7-solved" class="headerlink" title="DLP+ (7 solved)"></a>DLP+ (7 solved)</h1><blockquote>
<ul>
<li><a href="DLP+/task.py">task.py</a></li>
</ul>
</blockquote>
<p>A simple idea is that we try to control $g^x$ (or $h^x$) to be small. Then we can get $h^x$ with some bruteforce and solve DLP to get $x$. I found some luck on Mersenne Prime $p &#x3D; 2^n - 1$, where $g^x mod p$ is very small. Finally I chose M2281 for effective DLP solver. </p>
<p>Which took me a lot of time and luck, definitely NOT that effective.</p>
<blockquote>
<p>solution: <a href="DLP+/exp.py">exp.py</a></p>
</blockquote>
<p>@Sceleri and @soon_haari used $p &#x3D; 2^a \cdot 3^b + 1$. It does make more sense since $g &#x3D; 2^{a-1} \cdot 3^b$ and $h &#x3D; 2^a \cdot 3^{b-1}$ (same in our solution). But I donot want to go through it again so just let it go.</p>
<p><img src="/2025/03/04/secconctf2025/images/3.png" alt="image"></p>
<h1 id="hell-summon-6-solved"><a href="#hell-summon-6-solved" class="headerlink" title="hell_summon (6 solved)"></a>hell_summon (6 solved)</h1><blockquote>
<ul>
<li><a href="hell_summon/task.py">task.py</a></li>
</ul>
</blockquote>
<p>I spent the whole afternoon on this one in day1.</p>
<p>We have 42 pairs of $(m_i, c_i &#x3D; r \cdot (m_i  \oplus H) + e_i \pmod{p})$, where $e_i$ is due to the truncation. We rewrite $m_i \oplus H$ as $\Sigma_{j&#x3D;0}^{39} (m_{i, j} + H_{j} - 2 \cdot m_{i, j} \cdot H_{j}) \cdot 2^{j}$. </p>
<p>$$\Rightarrow \Sigma_{j&#x3D;0}^{39} r \cdot H_{j} \cdot ((1 - 2 \cdot m_{i, j}) \cdot 2^{j}) + r \cdot m_i  + e_i \pmod{p}$$</p>
<p>Orthogonal Lattice seems to be an adorable choice, and it worked well. On the first attempt I found one short vector $v$ where $\vec{v} \cdot \vec{c} &#x3D; \vec{v} \cdot \vec{e} \pmod{p}$, and it’s small enough to omit $p$. But I didn’t manage to solve $\vec{e}$.</p>
<p>On another attempt at midnight, I used vectors $(v_0, v_1)$ orthogonal to $\Sigma_{j&#x3D;0}^{39} r \cdot H_{j} \cdot ((1 - 2 \cdot m_{i, j}) \cdot 2^{j})$. Then we have two equations $r \cdot (\vec{v_i} \cdot \vec{m}) + \vec{v_i} \cdot \vec{e} \pmod{p}$, where $\vec{v_i} \cdot \vec{e}$ is small. Now we can solve it as a simple HNP.</p>
<blockquote>
<p>solution: <a href="hell_summon/exp.py">exp.py</a></p>
</blockquote>
<p>Definitely not a pleasing code but whatever.</p>
<h1 id="x-x-4-solved"><a href="#x-x-4-solved" class="headerlink" title="*x_x (4 solved)"></a>*x_x (4 solved)</h1><blockquote>
<ul>
<li><a href="x_x/task.sage">task.sage</a></li>
</ul>
</blockquote>
<p>Working on it. UOV and sth bluhbluhbluh.</p>
<h1 id="In-Japan"><a href="#In-Japan" class="headerlink" title="In Japan"></a>In Japan</h1><p>My first time to Japan, also my first time abroad. Not bad actually.</p>
<table>
<thead>
<tr>
<th><img src="/2025/03/04/secconctf2025/images/seccon.jpg" alt="seccon"></th>
<th><img src="/2025/03/04/secconctf2025/images/view.jpg" alt="view"></th>
<th><img src="/2025/03/04/secconctf2025/images/food.jpg" alt="food"></th>
</tr>
</thead>
</table>
<p>My teammates are very strong! Glad to work with them XD<br>And also great to meet many friends from P1G SEKAI.</p>
<p><img src="/2025/03/04/secconctf2025/images/view1.jpg" alt="view1"></p>
<table>
<thead>
<tr>
<th><img src="/2025/03/04/secconctf2025/images/view2.jpg" alt="view2"></th>
<th><img src="/2025/03/04/secconctf2025/images/view3.jpg" alt="view3"></th>
</tr>
</thead>
</table>
<p>Sincere thanks to @crazyman :D (Wish I could go to Mt. Fuji.)<br>I realy enjoyed Tokyo. It’d be better if I can hang out for one or two two more days.</p>
]]></content>
      <tags>
        <tag>UOV</tag>
        <tag>OL</tag>
      </tags>
  </entry>
</search>
